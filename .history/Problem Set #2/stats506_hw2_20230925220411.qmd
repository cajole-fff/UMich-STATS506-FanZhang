---
title: "STATS506 Problem Set #02"
author: "Fan Zhang"
date: "09/24/2023"
format:
    html:
        embed-resources: true 
        code-line-numbers: true
        # code-fold: true
editor: 
    render-on-save: false 
---

GitHub Repository: [https://github.com/cajole-fff/UMich-STATS506-FanZhang/](https://github.com/cajole-fff/UMich-STATS506-FanZhang/)

## Problem 1 - Dice Game 

Let's play a dice game. It costs $2 to play. You roll a single 6-sided die.
* On a roll of 2, 4, or 6, you win the amount on the roll (e.g. a roll of 4 wins $4).
* On a roll of 1, 3, or 5, you lose.
We're going to implement this in different ways. Each function takes in as input the number of dice to roll, and each function returns your total winnings or loses. 

**a. Implement various versions of this game. **

Version 1. Implement this game using a loop over the die rolls. 

```{r}
play_dice_lp <- function(num_die_rolls = 1){
    winnings <- 0
    for(i in 1:num_die_rolls){
        roll <- sample(1:6, 1)
        winnings <- winnings + (1 - (roll %% 2)) * roll - 2
    }
    return(winnings)
}
```

Version 2. Implement this game using built-in R vectorized functions.

```{r}
play_dice_vt <- function(num_die_rolls = 1){
    rolls <- sample(1:6, num_die_rolls, replace = TRUE)
    winnings <- sum((1 - (rolls %% 2)) * rolls) - 2 * num_die_rolls
    return(winnings)
}
```

Version 3. Implement this by collapsing the die rolls into a single `table()`. (Hint: Be careful indexing the table - what happens if you make a table of 5 dice rolls? You may need to look to other resources for how to solve this.)

```{r}
play_dice_tb <- function(num_die_rolls = 1){
    rolls <- sample(1:6, num_die_rolls, replace = TRUE)
    rolls <- table(rolls)
    winnings <- sum(as.numeric(names(rolls)) * (1 - (as.numeric(names(rolls)) %% 2)) * rolls) - 2 * num_die_rolls
    return(winnings)
}
```

Version 4. Implement this game by using one of the "apply" functions.

```{r}
single_roll_amount <- function(roll) {
    return ((1 - (roll %% 2)) * roll)
}

play_dice_ap <- function(num_die_rolls = 1){
    rolls <- sample(1:6, num_die_rolls, replace = TRUE)
    winnings <- sum(sapply(rolls, single_roll_amount)) - 2 * num_die_rolls
    return(winnings)
}
```

**b. Demonstrate that all versions work. Do so by running each a few times, once with an input a 3, and once with an input of 3000.**
```{r}
cat("play_dice_lp(3):", play_dice_lp(3), "\n")
cat("play_dice_lp(3000):", play_dice_lp(3000), "\n")
cat("play_dice_vt(3):", play_dice_vt(3), "\n")
cat("play_dice_vt(3000):", play_dice_vt(3000), "\n")
cat("play_dice_tb(3):", play_dice_tb(3), "\n")
cat("play_dice_tb(3000):", play_dice_tb(3000), "\n")
cat("play_dice_ap(3):", play_dice_ap(3), "\n")
cat("play_dice_ap(3000):", play_dice_ap(3000), "\n")
```

**c. Demonstrate that the four versions give the same result. Test with inputs 3 and 3000. (You may need to add a way to control the randomization.)**

Set a random seed:
```{r}
random_seed <- 93
```

Test those functions:

```{r}
set.seed(random_seed)
cat("play_dice_lp(3):", play_dice_lp(3), "\n")
set.seed(random_seed)
cat("play_dice_vt(3):", play_dice_vt(3), "\n")
set.seed(random_seed)
cat("play_dice_tb(3):", play_dice_tb(3), "\n")
set.seed(random_seed)
cat("play_dice_ap(3):", play_dice_ap(3), "\n")
set.seed(random_seed)
cat("play_dice_lp(3000):", play_dice_lp(3000), "\n")
set.seed(random_seed)
cat("play_dice_vt(3000):", play_dice_vt(3000), "\n")
set.seed(random_seed)
cat("play_dice_tb(3000):", play_dice_tb(3000), "\n")
set.seed(random_seed)
cat("play_dice_ap(3000):", play_dice_ap(3000), "\n")
```

**d. Use the `microbenchmark` package to clearly demonstrate the speed of the implementations. Compare performance with a low input (100) and a large input (10000). Discuss the results.**

```{r}
library(microbenchmark)
mb_100 <- microbenchmark(lp=play_dice_lp(100), vt=play_dice_vt(100), tb=play_dice_tb(100), ap=play_dice_ap(100))
mb_10000 <- microbenchmark(lp=play_dice_lp(10000), vt=play_dice_vt(10000), tb=play_dice_tb(10000), ap=play_dice_ap(10000))
print(mb_100)
print(mb_10000)
```

As shown above, `play_dice_vt` is fastest, and  `play_dice_lp` is slowest. It is because the `play_dice_vt` utilizes vectorized calculation, which has many builtin optimizations. On the contrary, `play_dice_lp` uses `for` loops and it need to check the condition, allocate memory and calculate the result in each iteration, which is time-consuming. Function `play_dice_tb` counts the number of each element in the `rolls` vector before calculating the winning amount, which is slower than direct calculation; function `play_dice_ap` uses `sapply` is even slower, but still faster than `play_dice_lp`.

**e. Do you think this is a fair game? Defend your decision with evidence based upon a Monte Carlo simulation.**
```{r}
# Run a Monte Carlo simulation
monte_carlo <- function(num_simulations = 1000, num_die_rolls = 100){
    winnings <- rep(0, num_simulations)
    for(i in 1:num_simulations){
        winnings[i] <- play_dice_vt(num_die_rolls)
    }
    return(winnings)
}
sim_result <- monte_carlo(100000, 100)
# Calculate average winning amount
cat("Average winning amount:", mean(sim_result), "\n")
# Histogram of winning amount with normal distribution
hist(sim_result, breaks = 100, freq = FALSE, main = "Histogram of winning amount", xlab = "Winning amount")
# Add a normal curve
curve(dnorm(x, mean = mean(sim_result), sd = sd(sim_result)), col = "red", lwd = 2, add = TRUE)
```

According to the simulation above, the winning amount roughly follows a normal distribution with zero mean, and the average winning amount is -0.02452, which is close to 0. Therefore, I think this is a fair game.


## Problem 2 - Linear Regression 

Download the cars data set available at [https://corgis-edu.github.io/corgis/csv/cars/](https://corgis-edu.github.io/corgis/csv/cars/). The goal is to examine the relationship between horsepower and highway gas mileage.

```{r}
# Load the data 
cars <- read.csv('./cars.csv')
summary(cars)
```

**a. The names of the variables in this data are way too long. Rename the columns of the data to more reasonable lengths.** 

```{r}
colnames(cars) <- c('height', 'length', 'width', 'driveline', 'engine_type', 'hybrid', 'num_fwd_gears', 'transmission', 'city_mpg', 'fuel_type', 'highway_mpg', 'classification', 'id', 'make', 'model_year', 'year', 'horsepower', 'torque')
summary(cars)
```

**b. Restrict the data to cars whose Fuel Type is "Gasoline".** 

```{r}
cars <- cars[cars$fuel_type == 'Gasoline', ]
```

**c. Fit a linear regression model predicting MPG on the highway. The predictor of interest is horsepower. Control for:**

* **The torque of the engine**
* **All three dimensions of the car**
* **The year the car was released, as a categorical variable**

**Briefly discuss the estimated relationship between horsepower and highway MPG. Be precise about the interpretation of the estimated coefficient.**

```{r}
# Fit a linear regression model
model <- lm(highway_mpg ~ horsepower + torque + height + length + width + factor(year), data = cars)
summary(model)
```

According to the summary above, highway MPG is positively correlated with horsepowe, with an estimated coefficient `0.0163556`. If other variable remain unchanged, highway MPG will increase by `0.0163556` for each unit increase in horsepower. Since the 


**d. It seems reasonable that there may be an interaction between horsepower and torque. Refit the model (with `lm()`) and generate an interaction plot, showing how the relationship between horsepower and MPG changes as torque changes. Choose reasonable values of horsepower, and show lines for three different reasonable values of torque.** 

**(Hint: If you choose to use the interactions package for this, look at the `at =` argument to help with how year comes into play - choose a reasonable single value for year.)**

```{r}
# Refit the model
model <- lm(highway_mpg ~ horsepower * torque + height + length + width + factor(year), data = cars)
# Generate an interaction plot
library(interactions)
interact_plot(model, pred = horsepower, modx = torque, interval = TRUE, at = list(torque = c(200, 300, 400)))
```