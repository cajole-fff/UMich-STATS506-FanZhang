---
title: "STATS506 Problem Set #02"
author: "Fan Zhang"
date: "09/24/2023"
format:
    html:
        embed-resources: true 
        code-line-numbers: true
        # code-fold: true
editor: 
    render-on-save: false 
---

GitHub Repository: [https://github.com/cajole-fff/UMich-STATS506-FanZhang/](https://github.com/cajole-fff/UMich-STATS506-FanZhang/)

## Problem 1 - Dice Game 

Let's play a dice game. It costs $2 to play. You roll a single 6-sided die.
* On a roll of 2, 4, or 6, you win the amount on the roll (e.g. a roll of 4 wins $4).
* On a roll of 1, 3, or 5, you lose.
We're going to implement this in different ways. Each function takes in as input the number of dice to roll, and each function returns your total winnings or loses. 

**a. Implement various versions of this game. **

Version 1. Implement this game using a loop over the die rolls. 

```{r}
play_dice_lp <- function(num_die_rolls = 1){
    winnings <- 0
    for(i in 1:num_die_rolls){
        roll <- sample(1:6, 1)
        # cat("roll:", roll, "\n")
        winnings <- winnings + (1 - 2 * (roll %% 2)) * roll
        # cat("winnings:", winnings, "\n")
    }
    return(winnings)
}
```

Version 2. Implement this game using built-in R vectorized functions.

```{r}
play_dice_vt <- function(num_die_rolls = 1){
    rolls <- sample(1:6, num_die_rolls, replace = TRUE)
    # cat("rolls:", rolls, "\n")
    winnings <- sum((1 - 2 * (rolls %% 2)) * rolls)
    # cat("winnings:", winnings, "\n")
    return(winnings)
}
```

Version 3. Implement this by collapsing the die rolls into a single `table()`. (Hint: Be careful indexing the table - what happens if you make a table of 5 dice rolls? You may need to look to other resources for how to solve this.)

```{r}
play_dice_tb <- function(num_die_rolls = 1){
    rolls <- sample(1:6, num_die_rolls, replace = TRUE)
    rolls <- table(rolls)
    winnings <- sum((1 - 2 * (as.numeric(names(rolls)) %% 2)) * as.numeric(names(rolls)) * rolls)
    # cat("rolls:", rolls, "\n")
    # cat("winnings:", winnings, "\n")
    return(winnings)
}
```

Version 4. Implement this game by using one of the "apply" functions.

```{r}
single_roll_amount <- function(roll) {
    return((1 - 2 * (roll %% 2)) * roll)
}

play_dice_ap <- function(num_die_rolls = 1){
    rolls <- sample(1:6, num_die_rolls, replace = TRUE)
    winnings <- sum(sapply(rolls, single_roll_amount))
    # cat("rolls:", rolls, "\n")
    # cat("winnings:", winnings, "\n")
    return(winnings)
}

play_dice_ap(10)
```

**b. Demonstrate that all versions work. Do so by running each a few times, once with an input a 3, and once with an input of 3000.**
```{r}
cat("play_dice_lp(3):", play_dice_lp(3), "\n")
cat("play_dice_lp(3000):", play_dice_lp(3000), "\n")
cat("play_dice_vt(3):", play_dice_vt(3), "\n")
cat("play_dice_vt(3000):", play_dice_vt(3000), "\n")
cat("play_dice_tb(3):", play_dice_tb(3), "\n")
cat("play_dice_tb(3000):", play_dice_tb(3000), "\n")
cat("play_dice_ap(3):", play_dice_ap(3), "\n")
cat("play_dice_ap(3000):", play_dice_ap(3000), "\n")
```

**c. Demonstrate that the four versions give the same result. Test with inputs 3 and 3000. (You may need to add a way to control the randomization.)**

Set a random seed:
```{r}
random_seed <- 93
```

Test those functions:

```{r}
set.seed(random_seed)
cat("play_dice_lp(3):", play_dice_lp(3), "\n")
set.seed(random_seed)
cat("play_dice_vt(3):", play_dice_vt(3), "\n")
set.seed(random_seed)
cat("play_dice_tb(3):", play_dice_tb(3), "\n")
set.seed(random_seed)
cat("play_dice_ap(3):", play_dice_ap(3), "\n")
set.seed(random_seed)
cat("play_dice_lp(3000):", play_dice_lp(3000), "\n")
set.seed(random_seed)
cat("play_dice_vt(3000):", play_dice_vt(3000), "\n")
set.seed(random_seed)
cat("play_dice_tb(3000):", play_dice_tb(3000), "\n")
set.seed(random_seed)
cat("play_dice_ap(3000):", play_dice_ap(3000), "\n")
```

**d. Use the `microbenchmark` package to clearly demonstrate the speed of the implementations. Compare performance with a low input (100) and a large input (10000). Discuss the results.**

```{r}
library(microbenchmark)
mb_100 <- microbenchmark(play_dice_lp(100), play_dice_vt(100), play_dice_tb(100), play_dice_ap(100))
mb_10000 <- microbenchmark(play_dice_lp(10000), play_dice_vt(10000), play_dice_tb(10000), play_dice_ap(10000))
print(mb_100)
print(mb_10000)
```

As shown above, `play_dice_vt` is fastest, and  `play_dice_lp` is slowest. It is because the `play_dice_vt` utilizes vectorized calculation, which has many builtin optimizations. On the contrary, `play_dice_lp` uses `for` loops and it need to check the condition, allocate memory and calculate the result in each iteration, which is time-consuming. Function `play_dice_tb` counts the number of each element in the `rolls` vector before calculating the winning amount, which is slower than direct calculation; function `play_dice_ap` uses `sapply` is even slower, but still faster than `play_dice_lp`.

**e. Do you think this is a fair game? Defend your decision with evidence based upon a Monte Carlo simulation.**

```{r}
# Run a Monte Carlo simulation
monte_carlo <- function(num_simulations = 10000, num_die_rolls = 100){
    winnings <- rep(0, num_simulations)
    for(i in 1:num_simulations){
        winnings[i] <- play_dice_vt(num_die_rolls)
    }
    return(winnings)
}
sim_result <- monte_carlo(10000, 100)
# Calculate average winning amount
cat("Average winning amount:", mean(sim_result), "\n")
# Histogram of winning amount with normal distribution
freq_table <- table(sim_result) / length(sim_result)
barplot(freq_table, main = "Frequency Distribution of sim_result", xlab = "sim_result")
# hist(sim_result, breaks = 100)
curve(dnorm(x, mean = mean(sim_result), sd = sd(si)), col = "red", add = TRUE)
```